\documentclass[aspectratio=169]{beamer}

% Idioma y codificación
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

% Colores y código
\usepackage{xcolor}
\usepackage{listings}
\usepackage{textcomp}

\definecolor{codebg}{rgb}{0.96,0.96,0.96}
\definecolor{codeframe}{rgb}{0.85,0.85,0.85}
\definecolor{codedk}{rgb}{0.2,0.2,0.2}
\definecolor{kw}{rgb}{0.15,0.15,0.6}
\definecolor{str}{rgb}{0.5,0.1,0.1}

\lstdefinestyle{cppstyle}{
  language=C++,
  basicstyle=\ttfamily\small\color{codedk},
  keywordstyle=\bfseries\color{kw},
  stringstyle=\color{str},
  commentstyle=\itshape\color{gray},
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=8pt,
  frame=single,
  rulecolor=\color{codeframe},
  frameround=tttt,
  backgroundcolor=\color{codebg},
  tabsize=2,
  breaklines=true,
  columns=fullflexible
}

% Tema Beamer
\usetheme{Madrid}
\usecolortheme{default}

% Metadatos
\title[POO e AutoBus]{Programación Orientada a Objetos (POO) aplicada a un AutoBus}
\author{Tu Nombre}
\institute{COM200}
\date{\\\small Requisito: Simulación de autobús con combustible, asientos y pasajeros}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Agenda}
  \tableofcontents
\end{frame}

\section{Qué es POO}

\begin{frame}{Qué es Programación Orientada a Objetos}
  \begin{itemize}
    \item \textbf{POO}: paradigma que modela el software como una colección de \textbf{objetos} que colaboran.
    \item Cada objeto pertenece a una \textbf{clase} que define su estructura (\textbf{atributos}) y comportamiento (\textbf{métodos}).
    \item Beneficios: \textbf{encapsulamiento}, \textbf{abstracción}, \textbf{reutilización}, \textbf{mantenibilidad}.
  \end{itemize}
\end{frame}

\section{Bloques fundamentales}

\begin{frame}{Clases y Objetos}
  \begin{block}{Clase}
    Plantilla/definición que describe qué datos (atributos) y qué operaciones (métodos) poseen los objetos del mismo tipo.
  \end{block}
  \begin{block}{Objeto}
    Instancia concreta de una clase con un \textbf{estado} propio y un \textbf{comportamiento} definido por su clase.
  \end{block}
  \vspace{4pt}
  \textbf{Ejemplo conceptual:} La clase \texttt{AutoBus} describe un autobús; el objeto \texttt{miAutoBus} es un autobús específico con su combustible, asientos y pasajeros.
\end{frame}

\begin{frame}{Atributos, Métodos y Encapsulamiento}
  \begin{itemize}
    \item \textbf{Atributos}: datos que representan el estado (p.ej., \texttt{combustible}, \texttt{asientos}, \texttt{tarifa}, \texttt{pasajeros}).
    \item \textbf{Métodos}: operaciones que modifican/consultan el estado (p.ej., \texttt{recogerPasajeros()}, \texttt{calcularAsientosDisponibles()}, \texttt{estaVacio()}).
    \item \textbf{Encapsulamiento}: ocultar los detalles internos y exponer una interfaz segura (visibilidad \texttt{private}/\texttt{public}).
  \end{itemize}
\end{frame}

\begin{frame}{Constructores e Invariantes}
  \begin{itemize}
    \item \textbf{Constructor}: método especial para inicializar objetos con un estado válido.
    \item \textbf{Invariante de clase}: condiciones que siempre deben cumplirse (p.ej., combustible ≤ 100, pasajeros ≤ asientos).
    \item Validar en el constructor y en los métodos que modifiquen el estado.
  \end{itemize}
\end{frame}

\section{Métodos: con y sin retorno}

\begin{frame}{Métodos que devuelven valores}
  \begin{itemize}
    \item Responden preguntas sin cambiar el estado (idealmente): \textbf{consultas}.
    \item Devuelven un valor: p.ej., \texttt{int calcularAsientosDisponibles()}, \texttt{bool hayEspacio()}.
    \item Facilitan separar \textbf{cálculo} de \textbf{efecto}, mejorando testeo y claridad.
  \end{itemize}
\end{frame}

\begin{frame}{Métodos sin retorno (procedimientos)}
  \begin{itemize}
    \item Ejecutan acciones con \textbf{efecto} sobre el estado: p.ej., \texttt{void recogerPasajeros(int nroPasajeros)}.
    \item Deben validar precondiciones y mantener invariantes (no exceder límites).
    \item Pueden lanzar excepciones si no se cumplen las condiciones.
  \end{itemize}
\end{frame}

\section{Del requisito al diseño}

\begin{frame}{Resumen del requisito (AutoBus)}
  \begin{itemize}
    \item Atributos: combustible, número de asientos, tarifa por persona, número de pasajeros.
    \item Constructor por defecto y uno configurable con combustible inicial.
    \item Límite de combustible: 100 unidades.
    \item Funcionalidades: recoger pasajeros, recargar gasolina, consultar disponibilidad, calcular recaudación.
  \end{itemize}
\end{frame}

\begin{frame}{Identificación de atributos y operaciones}
  \textbf{Atributos (estado):}
  \begin{itemize}
    \item \texttt{combustible: double} (máximo 100)
    \item \texttt{asientos: int}
    \item \texttt{tarifa: double}
    \item \texttt{pasajeros: int}
  \end{itemize}
  \vspace{6pt}
  \textbf{Métodos (comportamiento):}
  \begin{itemize}
    \item Consultas: \texttt{calcularAsientosDisponibles()}, \texttt{hayEspacio()}, \texttt{estaVacio()}, \texttt{calcularMontoRecaudado()}.
    \item Acciones: \texttt{recogerPasajeros(nroPasajeros)}, \texttt{recargarGasolina(cantidad)}.
  \end{itemize}
\end{frame}

\section{Diseño e implementación}

\begin{frame}[fragile]{Diseño de la clase \texttt{AutoBus} (C++) — Estructura}
\lstset{style=cppstyle}
\begin{lstlisting}
#include <stdexcept>
#include <string>

class AutoBus {
  private:
    double combustible;
    int asientos;
    double tarifa;
    int pasajeros;
    
    static const int COMBUSTIBLE_MAXIMO = 100;
    
    void validarNoNegativo(double valor, const std::string& nombre) const {
      if (valor < 0) throw std::invalid_argument(nombre + " no puede ser negativo");
    }
    
    void validarCombustible(double cantidad) const {
      if (cantidad > COMBUSTIBLE_MAXIMO) 
        throw std::invalid_argument("Combustible no puede exceder " + std::to_string(COMBUSTIBLE_MAXIMO));
    }

  public:
    // Constructor por defecto
    AutoBus() : combustible(0), asientos(50), tarifa(1.0), pasajeros(0) {}
    
    // Constructor configurable
    AutoBus(double combustibleInicial) : asientos(50), tarifa(1.0), pasajeros(0) {
      validarNoNegativo(combustibleInicial, "combustibleInicial");
      validarCombustible(combustibleInicial);
      this->combustible = combustibleInicial;
    }
    
    // Constructor completo
    AutoBus(double combustibleInicial, int asientos, double tarifa) 
      : pasajeros(0) {
      validarNoNegativo(combustibleInicial, "combustibleInicial");
      validarCombustible(combustibleInicial);
      if (asientos <= 0) throw std::invalid_argument("asientos > 0");
      validarNoNegativo(tarifa, "tarifa");
      
      this->combustible = combustibleInicial;
      this->asientos = asientos;
      this->tarifa = tarifa;
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Consultas en C++: separar cálculo de efecto}
\lstset{style=cppstyle}
\begin{lstlisting}
// Dentro de la clase AutoBus (métodos const):
int calcularAsientosDisponibles() const {
  return asientos - pasajeros;
}

bool hayEspacio() const {
  return pasajeros < asientos;
}

bool estaVacio() const {
  return pasajeros == 0;
}

double calcularMontoRecaudado() const {
  return pasajeros * tarifa;
}

// Getters para consultar estado
double getCombustible() const { return combustible; }
int getAsientos() const { return asientos; }
double getTarifa() const { return tarifa; }
int getPasajeros() const { return pasajeros; }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Comandos en C++: efectos e invariantes}
\lstset{style=cppstyle}
\begin{lstlisting}
// Dentro de la clase AutoBus:
void recogerPasajeros(int nroPasajeros) {
  if (nroPasajeros < 0) 
    throw std::invalid_argument("nroPasajeros >= 0");
  
  if (pasajeros + nroPasajeros > asientos) 
    throw std::logic_error("No hay suficientes asientos disponibles");
  
  pasajeros += nroPasajeros;
}

void recargarGasolina(double cantidad) {
  validarNoNegativo(cantidad, "cantidad gasolina");
  
  if (combustible + cantidad > COMBUSTIBLE_MAXIMO) 
    throw std::invalid_argument("Excedería el límite máximo de combustible");
  
  combustible += cantidad;
}

// Método para bajar pasajeros
void bajarPasajeros(int nroPasajeros) {
  if (nroPasajeros < 0) 
    throw std::invalid_argument("nroPasajeros >= 0");
  
  if (nroPasajeros > pasajeros) 
    throw std::logic_error("No hay tantos pasajeros en el bus");
  
  pasajeros -= nroPasajeros;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Uso en C++: instanciación y operaciones}
\lstset{style=cppstyle}
\begin{lstlisting}
#include <iostream>

int main() {
  try {
    // Crear autobús con constructor por defecto
    AutoBus bus1;
    std::cout << "Bus 1 - Asientos disponibles: " << bus1.calcularAsientosDisponibles() << "\n";
    
    // Crear autobús con combustible inicial
    AutoBus bus2(50.0);
    std::cout << "Bus 2 - Combustible: " << bus2.getCombustible() << "\n";
    
    // Crear autobús completo
    AutoBus bus3(75.0, 40, 2.5);
    std::cout << "Bus 3 - Tarifa: $" << bus3.getTarifa() << "\n";
    
    // Operaciones con bus3
    if (bus3.hayEspacio()) {
      bus3.recogerPasajeros(15);
      std::cout << "Pasajeros subieron. Asientos disponibles: " 
                << bus3.calcularAsientosDisponibles() << "\n";
      std::cout << "Monto recaudado: $" << bus3.calcularMontoRecaudado() << "\n";
    }
    
    bus3.recargarGasolina(20.0);
    std::cout << "Combustible después de recarga: " << bus3.getCombustible() << "\n";
    
  } catch (const std::exception& ex) {
    std::cerr << "Error: " << ex.what() << "\n";
  }
  return 0;
}
\end{lstlisting}
\end{frame}

\section{Buenas prácticas y extensiones}

\begin{frame}{Buenas prácticas aplicadas}
  \begin{itemize}
    \item Encapsular atributos como \texttt{private} y exponer sólo lo necesario.
    \item Validar entradas y mantener invariantes en constructor y métodos.
    \item Separar \textbf{consultas} (devuelven valores, sin efectos) de \textbf{comandos} (efectos, sin retorno).
    \item Usar constantes para valores mágicos (\texttt{COMBUSTIBLE\_MAXIMO}).
    \item Implementar múltiples constructores para flexibilidad.
  \end{itemize}
\end{frame}

\begin{frame}{Posibles extensiones}
  \begin{itemize}
    \item Métrica de \textit{nivel mínimo} de combustible y alertas preventivas.
    \item Soporte de diferentes tipos de tarifa (estudiante, adulto, tercera edad).
    \item Registro de historial de viajes (otra clase \texttt{Viaje}).
    \item Simulación de consumo de combustible por distancia recorrida.
    \item Pruebas unitarias de consultas y comandos por separado.
  \end{itemize}
\end{frame}

\begin{frame}{Cierre}
  \begin{itemize}
    \item POO ayuda a mapear \textbf{conceptos del dominio} a \textbf{código} de forma clara y mantenible.
    \item La clase \texttt{AutoBus} encapsula reglas del problema y valida límites.
    \item Distinguir entre métodos con retorno (cálculo) y sin retorno (acción) mejora el diseño y las pruebas.
    \item Los constructores múltiples proporcionan flexibilidad en la creación de objetos.
  \end{itemize}
\end{frame}

\end{document}
